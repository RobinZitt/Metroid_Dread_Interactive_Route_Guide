<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Route Guide</title>
    <style>

        /* Dropdown Button */
        .dropButton {
            height: auto;
        }

        /* The container <div> - needed to position the dropdown content */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        /* Dropdown Content (Hidden by Default) */
        .dropdown-content {
            display: none;
            position: absolute;
            min-width: 200px;
            z-index: 1;
        }

        /* Links inside the dropdown */
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: inline-block;
        }

        /* Change color of dropdown links on hover */
        .dropdown-content a:hover {background-color: #ddd;}

        /* Show the dropdown menu on hover */
        .dropdown:hover .dropdown-content {display: block;}

        /* Change the background color of the dropdown button when the dropdown content is shown */

        .imageContainer{
            position:relative;
            overflow:hidden;
            height:90%;
            width:auto;
        }
        .step{
            overflow: scroll;
            height:100%;
            width:auto;
            scroll-behavior: smooth;
        }


        .mapContainer{position: relative;}

        .mapContainer img{display: block;}

        .mapContainer .arrowPos{position: absolute;}


        .row {
            width: 100%;
            height: 90vh;
        }
        .row2 {
            width: 100%;
            height: 8vh;
        }

        .videoContainer {
            position: relative;
            height: 90%;
        }
        .videos {
            position: absolute;
            height: 100%;
        }

        .routeSelection {
            height: 10%;
        }

        .loadoutInfo {
            float: left;
        }

        .sidepanel {
            height: 150px;
            width: 0;
            position: fixed;
            z-index: 1;
            top: 0;
            right: -25px;
            overflow-x: hidden;
            padding-top: 60px;
            padding-left: 25px;
            transition: 0.5s;
            background-color: lightblue;
            border-radius: 20px;
        }

        .sidepanel .closeButton {
            position: absolute;
            top: 0;
            left: 25px;
            font-size: 36px;
            margin-right: 50px;
        }

        .bottompanel {
            height: 510px;
            width: 100%;
            position: fixed;
            z-index: 1;
            bottom: 0;
            left: 0;
            overflow-x: hidden;
            transition: 0.5s;
        }

        .bottompanel .closeButton {
            position: absolute;
            top: -5px;
            z-index: 2;
            right: 0;
            color: red;
            font-size: 36px;
            margin-right: 50px;
        }


        button, select{
            background-color: cyan;
            border: none;
            border-radius: 20px;
        }

        button:hover{
            background-color: lightskyblue;
        }
        input[type='checkbox'] {
            background-color: cyan;
        }
        #videoControls{
            background-color: rgba(47,79,79,50%);
            border-radius: 10px;
            padding: 10px 30px;
            position: absolute;
            display: flex;
            bottom: 20px;
            z-index: 1;
        }

        #volumeSliderLabel{
            rotate: 270deg;
            transform: translate(76px,-91px);
            display: none;
        }


        #volumeButton:hover + #volumeSliderLabel, #volumeSliderLabel:hover {
            display: block;
        }

        .controlButtons{
            margin-left: 10px;
            margin-right: 10px;
        }

    </style>
</head>
<body>
<div class="row">
    <div class="routeSelection" id="routeSelection">
        <label>
            <select id="glitchCategorySelect">
                <option value="0">Unrestricted</option>
                <option value="1">Unrestricted (Multi-File)</option>
                <option value="2">No Major Glitches</option>
                <option value="3">Glitchless</option>
            </select>
        </label>
        <label>
            <select id="categorySelect">
                <option value="0">Any%</option>
                <option value="1">100%</option>
                <option value="2">All Bosses</option>
                <option value="3">0%</option>
                <option value="4">Minimum Items</option>
            </select>
        </label>
        <div class="dropdown">
            <button id="routesButton" class="dropButton">Alternatives</button>
            <div id="routeOptions" class="dropdown-content">

            </div>
        </div>
        <button id="generateButton">Generate</button>
        <button id="openButton" class="openButton" style="display: none">Show/Hide Loadout</button>
        <button id="mapButton" class="openButton" style="display: none">Show/Hide Map</button>
    </div>
    <div id="vCon" class="videoContainer" style="float: left">
        <video class="videos" style="display: none" id="Videos" src=""></video>
        <video class="videos" style="display: none" id="Videos2" src=""></video>
        <div id="videoControls" style="display: none">
            <button id="playButton" class="controlButtons">&#9654;<strong>||</strong></button>
            <label id="videoSliderLabel">
                <input type="range" id="videoSlider">
            </label>
            <button id="fullscreenButton" class="controlButtons">&#x26F6;</button>
            <button id="previousButton" class="controlButtons">&#9668;&#9668;</button>
            <button id="nextButton" class="controlButtons">&#9658;&#9658;</button>
            <button id="volumeButton" class="controlButtons">&#x1F50A;</button>
            <label id="volumeSliderLabel" style="margin-right: -133px">
                <input type="range" id="volumeSlider" min="0" max="1" step="0.1">
            </label>
        </div>
    </div>
    <div id="sidepanel" class="sidepanel" style="width: 0">
        <a href="javascript:void(0)" id="closeButton" class="closeButton">x</a>
        <div class="loadoutInfo" id="loadoutInfo">

        </div>
    </div>
</div>
<div class="row2">
    <div id="bottompanel" class="bottompanel" style="height: 0">
        <a href="javascript:void(0)" id="closeMap" class="closeButton">x</a>
        <button style="display: none" id="testButton">Test</button>
        <button style="display: none" id="previousButtonMap">Previous segment</button>
        <button style="display: none" id="nextButtonMap">Next segment</button>
        <div class="dropdown">
            <button style="display: none" id="zoomLevel" class="dropButton">Zoom level</button>
            <div class="dropdown-content">
                <button id="fullZoom">Full zoom</button>
                <button id="halfZoom">Half zoom</button>
                <button id="noZoom">No zoom</button>
            </div>
        </div>
        <div class="dropdown">
            <button style="display: none" id="arrowDisplay" class="dropButton">Arrow display</button>
            <div class="dropdown-content">
                <button id="singleArrow">Show single arrow</button>
                <button id="tripleArrows">Show neighbor arrows</button>
                <button id="upgradeArrows">Show arrows until next upgrade</button>
                <button id="allArrows">Show all arrows</button>
                <button id="noArrows">Show no arrows</button>
            </div>
        </div>
        <div style="display: none" id="imageContainer" class="imageContainer">
            <div id="mapContainer" class="step">
                <div class="mapContainer">
                    <img style="display: none" id="Maps" src="" alt="Image missing">
                    <div id="arrowContainer">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<script type="module">
    import {RouteData,routeCreate,LoadOutData, AlternativeRouteData} from "./routeData.mjs";
    import routeData from "./routeData.json" with {type:"json"};
    import alternativeRouteData from "./alternativeRoutes.json" with {type:"json"};
    import tutorialData from "./tutorialData.json" with {type:"json"};
    const arrowsFolderName = "./ArrowImages/";
    const mapsFolderName = "./Maps/";
    const videosFolderName = "./Videos/";
    document.body.style.backgroundImage = "url(BackgroundImages/Metroid_Dread_Overview_Dread_Img01.jpg)";
    document.body.style.backgroundSize = "cover";
    document.getElementById("previousButton").addEventListener("click", previousVideo);
    document.getElementById("nextButton").addEventListener("click", nextVideo);
    document.getElementById("previousButtonMap").addEventListener("click", () => previousVideo(undefined, false));
    document.getElementById("nextButtonMap").addEventListener("click", () => nextVideo(undefined, false));
    document.getElementById("generateButton").addEventListener("click",generateRoute);
    document.getElementById("testButton").addEventListener("click",testing);
    document.getElementById("fullZoom").addEventListener("click", () => updateZoom("fullZoom"));
    document.getElementById("halfZoom").addEventListener("click", () => updateZoom("halfZoom"));
    document.getElementById("noZoom").addEventListener("click", () => updateZoom("noZoom"));
    document.getElementById("singleArrow").addEventListener("click", () => updateDisplayStyle("single"));
    document.getElementById("tripleArrows").addEventListener("click", () => updateDisplayStyle("triple"));
    document.getElementById("upgradeArrows").addEventListener("click", () => updateDisplayStyle("upgrade"));
    document.getElementById("allArrows").addEventListener("click", () => updateDisplayStyle("all"));
    document.getElementById("noArrows").addEventListener("click", () => updateDisplayStyle("none"));
    document.getElementById("glitchCategorySelect").addEventListener("change", updateAlternatives);
    document.getElementById("openButton").addEventListener("click", openLoadoutInfo);
    document.getElementById("closeButton").addEventListener("click",closeLoadoutInfo);
    document.getElementById("mapButton").addEventListener("click", openMap);
    document.getElementById("closeMap").addEventListener("click",closeMap);
    document.getElementById("playButton").addEventListener("click",playPause);
    document.getElementById("fullscreenButton").addEventListener("click",fullscreen);
    document.getElementById("videoSlider").addEventListener("input",progressBar);
    document.getElementById("videoSlider").defaultValue = 0;
    document.getElementById("volumeSlider").addEventListener("input", changeVolume);
    document.onfullscreenchange = function (){fullscreenChanger()};
    let mapOpen = false;
    window.addEventListener('click', function (e){
        if (mapOpen && !document.getElementById("bottompanel").contains(e.target)){
            closeMap();
        }
    });
    window.addEventListener("resize",function (){
        zoom();
    });
    document.addEventListener('keydown', function (event){
        if (video.style.display === "none" && video2.style.display === "none") return;
        let isVideo1=(video.style.display === "block");
        let currentVideo = isVideo1 ? video : video2;
        switch (event.key){
            case "ArrowRight":{
                currentVideo.currentTime += 5;
                break;
            }
            case "ArrowLeft":{
                if (currentVideo.currentTime < 2) {
                    previousVideo(isVideo1, true, true);
                }
                else
                    currentVideo.currentTime -= 5;
                break;
            }
            case " ":{
                playPause();
                break;
            }
            case "l":{
                openLoadoutInfo();
                break;
            }
            case "m":{
                openMap();
                break;
            }
        }
    });
    let video = document.getElementById("Videos");
    let video2 = document.getElementById("Videos2");
    video.allowFullscreen = false;
    video2.allowFullscreen = false;
    video.addEventListener("ended",() => nextVideo(true));
    video2.addEventListener("ended",() => nextVideo(false));
    video.addEventListener("timeupdate",() => updateSlider());
    video2.addEventListener("timeupdate",() => updateSlider());
    video.addEventListener("resize", videoResize);
    video2.addEventListener("resize", videoResize);
    let videoCounter = 0;
    let zoomLevel = "fullZoom";
    let videoProgress;
    const mapHeight = "520px";
    let missileCount = 30;
    let eTankCount = 0;
    let ePartCount = 0;
    let currentLoadout = [];
    let tutorialLinks = [];
    let currentTutorials = [];
    let additionalInfoList = [];
    let currentAdditionalInfo = "";
    let arrowDisplayStyle = "upgrade";
    let completeLoadoutData = [];
    let image = document.getElementById("Maps");
    let mapSizeRatio = 1;
    let completeRoute = [];
    let arrowOrderedData = [];
    let routeLabel;
    let allRouteData = [];
    let allAlternativeRouteData = [];
    //Load route data and generate checkboxes
    for (let i = 0; i < alternativeRouteData.routes.length; i++) {
        let newAlternativeRoute = new AlternativeRouteData(
            alternativeRouteData.routes[i].routeName,
            alternativeRouteData.routes[i].fileName,
            alternativeRouteData.routes[i].routeActive,
            alternativeRouteData.routes[i].startIndex,
            alternativeRouteData.routes[i].endIndex,
            alternativeRouteData.routes[i].subRoutes,
            alternativeRouteData.routes[i].categories
        );
        allAlternativeRouteData.push(newAlternativeRoute);
        routeLabel = document.createElement(allAlternativeRouteData[i].routeName+"Label");
        routeLabel.id = allAlternativeRouteData[i].routeName+"Label";
        routeLabel.style.marginRight = "20px";
        let checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = allAlternativeRouteData[i].routeName+"Checkbox";
        checkbox.name = allAlternativeRouteData[i].routeName+"Checkbox";
        checkbox.style.accentColor = "cyan";
        let textContent = document.createTextNode(allAlternativeRouteData[i].routeName);
        routeLabel.append(textContent);
        routeLabel.append(checkbox);
        routeLabel.style.backgroundColor = "cyan";
        routeLabel.style.border = "none";
        routeLabel.style.borderRadius = "20px";
        document.getElementById("routeOptions").appendChild(routeLabel);
    }
    loadAdditionInfo();

    //generates an array of videos based on the selected route
    async function generateRoute() {
        //initialize variables
        videoCounter = 0;
        completeRoute = [];
        allRouteData = [];
        completeLoadoutData = [];
        tutorialLinks = [];
        additionalInfoList = [];
        let currentLoadoutData = new LoadOutData(30,0,0,[],[]);//TODO change missile count for normal mode
        arrowOrderedData = [];
        let currentRoomIds = [];
        let roomIndex = 0;
        //Load data into allRouteData
        for (let i = 0; i < routeData.routes.length; i++) {
            let newRoute = new RouteData(
                routeData.routes[i].routeName,
                routeData.routes[i].fileName,
                routeData.routes[i].routeActive,
                routeData.routes[i].startIndex,
                routeData.routes[i].endIndex,
                copySubRoutes(routeData.routes[i].subRoutes)
            );
            allRouteData.push(newRoute);
        }
        let routeName = getRoute();
        let startingRoute =  allRouteData.find((route) => route.routeName === routeName);
        addAlternativeRoutes(startingRoute);
        completeRoute = routeCreate(startingRoute, [], startingRoute.startIndex, startingRoute.endIndex, allRouteData);
        //Display videos, map and buttons
        video.style.display = "block";
        image.style.display = "block";
        let buttonArray = [
            "imageContainer",
            "previousButtonMap",
            "nextButtonMap",
            "videoControls",
            "testButton",
            "zoomLevel",
            "arrowDisplay",
            "openButton",
            "mapButton"
        ];
        for (const buttonName of buttonArray) {
            document.getElementById(buttonName).style.removeProperty("display");
        }
        const arrowContainer = document.getElementById("arrowContainer");
        //clear arrows before generating
        while (arrowContainer.firstChild) arrowContainer.removeChild(arrowContainer.lastChild);
        //position and display arrows
        for (let i = 0; i < completeRoute.length; i++) {
            let currentArrow;
            currentArrow = document.createElement("img");
            currentArrow.id = "arrow" + i;
            let folder = completeRoute[i].split("_")[0];
            let index = completeRoute[i].split("_")[1];
            try{
                currentArrow.src = arrowsFolderName + folder+"/"+ completeRoute[i] + ".png";
                let arrowDataImport = await import ("./ArrowData/"+folder+".json",{with: {type: "json"}});
                let arrowInfo = filterByIndex(arrowDataImport.default["info"], parseInt(index));
                currentArrow.classList.add("arrowPos");
                currentArrow.style.top = arrowInfo.topPosition + "px";
                currentArrow.style.left = arrowInfo.leftPosition + "px";
                /* TODO change system back to room ids later
                for (let j = 0; j < arrowInfo.roomIds.length; j++) {
                    if (currentRoomIds.includes(arrowInfo.roomIds[j])){
                        currentRoomIds = [];
                        roomIndex++;
                    }
                    currentRoomIds.push(arrowInfo.roomIds[j]);

                }
                */
                arrowOrderedData[i] = [arrowInfo.topPosition, arrowInfo.leftPosition, arrowInfo.zoom];
                currentArrow.addEventListener("click", function () {
                    arrowClicked(i)
                });
                //currentArrow.style.display = "none";
                document.getElementById("arrowContainer").appendChild(currentArrow);
            }
            catch (err){
                console.log("Arrow data for "+ completeRoute[i] +" not found");
            }
            //load loadout info
            try{
                let loadoutInfoImport = await import("./LoadoutInfo/"+folder+".json",{with: {type: "json"}});
                let loadoutInfo = filterByIndex(loadoutInfoImport.default["info"], parseInt(index));
                if (loadoutInfo.upgradeCollected.length !== 0) roomIndex++;
                arrowOrderedData[i][3] = roomIndex;
                currentLoadoutData = setLoadoutData(loadoutInfo.itemsCollected,loadoutInfo.upgradeCollected, currentLoadoutData);
                completeLoadoutData.push(currentLoadoutData);
                tutorialLinks.push(loadoutInfo.setupsUsed);
                additionalInfoList.push(loadoutInfo.additionalInfo);
            }
            catch (err){
                console.log("Loadout data for "+ completeRoute[i] +" not found");
            }
        }
        updateGuideView(false, false);
        document.getElementById("videoSlider").value = 0;
    }

    //get route name based on what route is currently selected
    function getRoute(){
        let glitchCategorySelect = document.getElementById("glitchCategorySelect");
        let glitchCategory = glitchCategorySelect.options[glitchCategorySelect.selectedIndex].text.toString();
        let categorySelect = document.getElementById("categorySelect");
        let category = categorySelect.options[categorySelect.selectedIndex].text.toString();
        let categoryName = "";
        let glitchCategoryName = "";
        switch (category){
            case "Any%":
                categoryName = "anyPercent";
                break;
            case "100%":
                categoryName = "hundo";
                break;
            case "All Bosses":
                categoryName = "AB";
                break;
            case "0%":
                categoryName = "zeroPercent";
                break;
            case "Minimum Items":
                categoryName = "MinItems";
        }
        switch (glitchCategory){
            case "Unrestricted":
                glitchCategoryName = "UR";
                break;
            case "Unrestricted (Multi-File)":
                glitchCategoryName = "UR-MF";
                break;
            case "No Major Glitches":
                glitchCategoryName = "NMG";
                break;
            case "Glitchless":
                glitchCategoryName = "GL";
                break;
        }
        return categoryName + "_" + glitchCategoryName;
    }

    //Show or hide alternative route options depending on if they are available for this route
    function updateAlternatives(){
        let routeName = getRoute();
        for (let i = 0; i < allAlternativeRouteData.length; i++) {
            let mainRoute = allAlternativeRouteData[i].categories.find((category) => category.name === routeName);
            let altRoute = document.getElementById(allAlternativeRouteData[i].routeName+"Label");
            if (mainRoute !== undefined) {
                altRoute.style.display = "block";
            }
            else{
                altRoute.style.display = "none";
                altRoute.lastChild.checked = false;
            }
        }
    }

    //Add alternative routes as selectable options
    function addAlternativeRoutes(mainRoute){
        let routeOptions = document.getElementById("routeOptions").children;
        for (let i = 0; i < routeOptions.length; i++) {
            let subRouteName = routeOptions[i].firstChild.textContent;
            let subRouteActive = routeOptions[i].lastChild.checked;
            if (subRouteActive) setAlternativeRoute(subRouteName, mainRoute);
        }
    }

    //Integrate an alternative route to the current route
    function setAlternativeRoute(routeName, mainRoute){
        let categoryName = mainRoute.routeName;
        let route = allAlternativeRouteData.find((route) => route.routeName === routeName);
        let categoryIndexes = route.categories.find((category) => category.name === categoryName);
        let subRoute = {
            "subRouteName": route.routeName,
            "subRouteStart": categoryIndexes.subRouteStart,
            "subRouteReturn": categoryIndexes.subRouteReturn,
            "startIndex": route.startIndex,
            "endIndex": route.endIndex,
            "subRouteActive": route.routeActive
        }
        for (let i = 0; i < mainRoute.subRoutes.length; i++) {
            if (subRoute.subRouteStart < mainRoute.subRoutes[i].subRouteStart){
                mainRoute.subRoutes.splice(i,0,subRoute);
                return;
            }
        }
    }

    //Returns a copy of a subroute
    function copySubRoutes(subRoutes){
        let SubRoutesCopy = [];
        for (let i = 0; i < subRoutes.length; i++) {
            let newSubRoute = {
                "subRouteName": subRoutes[i].subRouteName,
                "subRouteStart": subRoutes[i].subRouteStart,
                "subRouteReturn": subRoutes[i].subRouteReturn,
                "startIndex": subRoutes[i].startIndex,
                "endIndex": subRoutes[i].endIndex,
                "subRouteActive": subRoutes[i].subRouteActive
            }
            SubRoutesCopy.push(newSubRoute);
        }
       return SubRoutesCopy;
    }

    //For testing purposes only. Centers map on current arrow
    function testing(){
        document.getElementById("arrow"+videoCounter).scrollIntoView({
            behavior: 'auto',
            block: 'center',
            inline: 'center'
        });
    }

    //Show the next video in the array. Is usually called after the last video ended
    function nextVideo(isVideo1=(video.style.display === "block"),autoplay=true){
        if (videoCounter >= completeRoute.length -1) return;
        videoCounter++;
        updateGuideView(isVideo1,autoplay,false);
    }

    //Show the previous video
    function previousVideo(isVideo1=(video.style.display === "block"),autoplay=true,playFromEnd=false){
        if (videoCounter < 1) return;
        videoCounter--;
        updateGuideView(isVideo1,autoplay,playFromEnd);
    }

    //Shows the current video and hides the other one. Loads the next video in the background if possible
    function changeVideo(isVideo1,autoPlay,playFromEnd=false){//get isVideo1 from blocked?
        let currentVideo = isVideo1 ? video : video2;
        let nextVideo = isVideo1 ? video2 : video;
        currentVideo.pause();
        currentVideo.style.display = "none";
        nextVideo.style.display = "block";
        let folder = completeRoute[videoCounter].split("_")[0]+"/";
        if (nextVideo.getAttribute("src") !== videosFolderName+folder+completeRoute[videoCounter]+".mp4"){
            let source = videosFolderName+folder+completeRoute[videoCounter]+".mp4";
            nextVideo.setAttribute("src",source);
            nextVideo.load();
            nextVideo.onloadedmetadata = () => {
                if (nextVideo.duration > 5 && playFromEnd)
                    nextVideo.currentTime = nextVideo.duration - 5;
                playFromEnd = false;
            };
        }
        if (autoPlay) nextVideo.play();
        if (videoCounter < completeRoute.length - 1){
            let nextFolder = completeRoute[videoCounter+1].split("_")[0]+"/";
            currentVideo.setAttribute("src", videosFolderName+nextFolder+completeRoute[videoCounter+1]+".mp4");
            currentVideo.load();
            currentVideo.style.display="none";
        }
        let videoControls = document.getElementById("videoControls");
        if (document.fullscreenElement === null){
            videoControls.style.left = (nextVideo.style.left + nextVideo.offsetWidth/2 - videoControls.offsetWidth/2) + "px";
        }
        else{
            videoControls.style.left = (window.outerWidth/2 - videoControls.offsetWidth/2) + "px";
        }
    }


    //Loads in the image of the map
    function changeMap(){
        image.setAttribute("src", mapsFolderName+"artaria.png");//TODO adjust region
        image.onload = function() { zoom() };
    }

    //Zoom in on the map
    function halfZoom(){
        if (mapSizeRatio >= 1) return;
        mapSizeRatio += 0.1;
        zoom(mapSizeRatio);
    }

    //Zoom out of the map
    function fullZoom(){
        if (mapSizeRatio <= 0.11) return;
        mapSizeRatio -= 0.1;
        zoom(mapSizeRatio);
    }

    function updateZoom(newZoom){
        zoomLevel = newZoom;
        zoom();
    }


    //Zooms in or out on an arrow on the map
    function zoom(){
        let containerWidth;
        let containerHeight;
        try {
            let arrow = document.getElementById("arrow"+videoCounter);
            containerWidth = document.getElementById("mapContainer").clientWidth;
            containerHeight = document.getElementById("mapContainer").clientHeight;
            let zoomFactor = Math.min(containerWidth / arrow.naturalWidth, containerHeight / arrow.naturalHeight);
            mapSizeRatio = (zoomFactor * 0.9);
        }
        catch (err){
            console.log("arrow"+videoCounter+" does not exist!")
        }
        switch (zoomLevel){
            case "noZoom":{
                mapSizeRatio = containerWidth/image.naturalWidth;
                break;
            }
            case "halfZoom":{
                mapSizeRatio = Math.max(0.5*mapSizeRatio,0.2);
                break;
            }
            case "fullZoom":
            default:{
            }
        }
        updateArrows(mapSizeRatio);
        document.getElementById("Maps").style.width = mapSizeRatio * document.getElementById("Maps").naturalWidth.toString()+"px";
        if (videoCounter > 0) zoomOnArrow(false, videoCounter - 1);
        zoomOnArrow(true, videoCounter);
    }


    //Adjusts the size of the arrows depending on the level of zoom
    function updateArrows(zoom){
        for (let i = 0; i < arrowOrderedData.length; i++) {
            let currentArrow = document.getElementById("arrow"+i);
            currentArrow.style.width = zoom * currentArrow.naturalWidth.toString()+"px";
            currentArrow.style.top = zoom * arrowOrderedData[i][0]+"px";
            currentArrow.style.left = zoom * arrowOrderedData[i][1]+"px";
            displayArrows(arrowDisplayStyle, i, currentArrow);
        }
    }

    //Displays specific arrow based on displayStyle
    function displayArrows(displayStyle, index, currentArrow){// TODO add room id system
        switch (displayStyle) {
            case "upgrade":
                //every arrow until the next upgrade
                if (arrowOrderedData[videoCounter][3] === completeLoadoutData[index].loadOut.length){
                    currentArrow.style.display = "block";
                    break;
                }
                //arrow for next upgrade
                if (index > 0){
                    if(arrowOrderedData[videoCounter][3] === completeLoadoutData[index - 1].loadOut.length){
                        currentArrow.style.display = "block";
                        break;
                    }
                }
                currentArrow.style.display = "none";
                break;
            case "triple":
                if (index === videoCounter || (index - 1) === videoCounter || (index + 1) === videoCounter) currentArrow.style.display = "block";
                else currentArrow.style.display = "none";
                break;
            case "all":
                currentArrow.style.display = "block";
                break;
            case "none":
                currentArrow.style.display = "none";
                break;
            case "single":
            default:
                if (index === videoCounter) currentArrow.style.display = "block";
                else currentArrow.style.display = "none";
        }
    }

    //Updates the display style
    function updateDisplayStyle(displayStyle){
        arrowDisplayStyle = displayStyle;
        updateArrows(mapSizeRatio);
    }


    //Updates map and videos to fit the arrow clicked
    function arrowClicked(index){
        videoCounter = index;
        updateGuideView(false);
    }

    //Center map on arrow
    function zoomOnArrow(isSmooth, counter){
        let behaviour = isSmooth ? 'smooth':'instant';
        try {
            let arrow = document.getElementById("arrow"+counter);
                arrow.scrollIntoView({
                behavior: behaviour,
                block: 'center',
                inline: 'center'
            });

        }
        catch (err){
            console.log("arrow"+counter+" does not exist!")
        }
    }

    //Updates map, video and loadout
    function updateGuideView(isVideo1,autoPlay,playFromEnd=false){
        changeVideo(isVideo1,autoPlay,playFromEnd);
        changeMap();
        updateLoadoutData();
    }

    //Saves loadout data in an array for every room in the route
    function setLoadoutData(itemsCollected,upgradeCollected,loadoutData,) {
        let newLoadoutData = new LoadOutData(
            loadoutData.missiles,
            loadoutData.eTanks,
            loadoutData.eParts,
            [],
            []
        );
        for (const i in loadoutData.loadOut) {
            newLoadoutData.loadOut.push(loadoutData.loadOut[i]);
        }
        if (upgradeCollected.length > 0){
            newLoadoutData.loadOut.push(upgradeCollected);
            newLoadoutData.newItems.push(upgradeCollected);
        }
        for (const i in itemsCollected) {
            newLoadoutData.newItems.push(itemsCollected[i]);
            switch (itemsCollected[i]) {
                case "missile tank": newLoadoutData.missiles += 2;
                    break;
                case "missile tank +": newLoadoutData.missiles += 10;
                    break;
                case "e-part": if (newLoadoutData.eParts >= 3) {
                    newLoadoutData.eParts = 0;
                    newLoadoutData.eTanks += 1;
                }
                else newLoadoutData.eParts += 1;
                    break;
                case "e-tank": newLoadoutData.eTanks += 1;
                    break;
                case "": break;
                default: console.log("Invalid item name"+ itemsCollected[i]);
            }
        }
        return newLoadoutData;
    }

    //Updates the loadout data panel to fit the current video
    function updateLoadoutData(){//TODO make use of newItems list
        try{
            let loadout = completeLoadoutData[videoCounter];
            missileCount = loadout.missiles;
            eTankCount = loadout.eTanks;
            ePartCount = loadout.eParts;
            currentLoadout = loadout.loadOut;
            currentTutorials = [];
            let currentTutorialData = tutorialLinks[videoCounter];
            for (const i in currentTutorialData) {
                if (currentTutorialData[i].length !== 0){
                    currentTutorials.push(filterByTag(tutorialData["tutorials"] ,currentTutorialData[i]).links);
                }
            }
        }
        catch (err){
            console.log("Additional data is missing"+err);
        }
        loadAdditionInfo()
    }

    //Loads the loadout panel data and displays it
    function loadAdditionInfo(){
        const loadoutInfo = document.getElementById("loadoutInfo");
        while (loadoutInfo.firstChild) loadoutInfo.removeChild(loadoutInfo.lastChild);//clear arrows before generating
        let loadoutInfoBlock = document.createElement("p");
        loadoutInfoBlock.append(`Missiles: ${missileCount}`,document.createElement("BR"));
        loadoutInfoBlock.append(`E-Tanks: ${eTankCount}`,document.createElement("BR"));
        loadoutInfoBlock.append(`E-Parts: ${ePartCount}/4`,document.createElement("BR"));
        loadoutInfoBlock.append(`Current loadout: ${currentLoadout}`,document.createElement("BR"));
        loadoutInfoBlock.append(`Tutorials: ${currentTutorials}`,document.createElement("BR"));//TODO move to different section later

        document.getElementById("loadoutInfo").appendChild(loadoutInfoBlock);
    }

    //Opens the loadout panel or closes it depending on its current state
    function openLoadoutInfo(){
        let panel = document.getElementById("sidepanel");
        if (panel.style.width === "0px") panel.style.width = "250px";
        else panel.style.width = "0px";
    }

    //Closes the loadout panel
    function closeLoadoutInfo(){
        document.getElementById("sidepanel").style.width = "0px";
    }

    function openMap(){
        let panel = document.getElementById("bottompanel");
        if (panel.style.height === "0px") {
            panel.style.height = mapHeight;
            setTimeout(function (){mapOpen = true});
        }
        else {
            panel.style.height = "0px";
            mapOpen = false;
        }
        reload();
    }

    function closeMap(){
        document.getElementById("bottompanel").style.height = "0px";
        mapOpen = false;
    }

    function reload(){
        let container = document.getElementById("imageContainer");
        container.style.height = "500px";
        changeMap();
    }

    function playPause(){
        let isVideo1=(video.style.display === "block")
        let currentVideo = isVideo1 ? video : video2;
        if (currentVideo.paused) currentVideo.play();
        else currentVideo.pause();
    }

    function fullscreen(){
        if (document.fullscreenElement === null)
            document.getElementById("vCon").requestFullscreen();
        else
            document.exitFullscreen();
    }
    function fullscreenChanger() {
        let videoContainer = document.getElementById("vCon");
        let videoControls = document.getElementById("videoControls");
        let isVideo1=(video.style.display === "block")
        let currentVideo = isVideo1 ? video : video2;
        if (videoContainer === document.fullscreenElement){
            video.style.width = "100%";
            video2.style.width = "100%";
            videoControls.style.left = (window.outerWidth/2 - videoControls.offsetWidth/2) + "px";
        }
        else {
            video.style.removeProperty("width");
            video2.style.removeProperty("width");
            videoControls.style.left = (currentVideo.style.left + currentVideo.offsetWidth/2 - videoControls.offsetWidth/2) + "px";
        }
        if (document.fullscreenElement === video){
            document.exitFullscreen();
        }
        if (document.fullscreenElement === video2){
            document.exitFullscreen();
        }
    }

    function progressBar(){
        videoProgress = document.getElementById("videoSlider").value;
        let isVideo1=(video.style.display === "block")
        let currentVideo = isVideo1 ? video : video2;
        currentVideo.currentTime = currentVideo.duration * (videoProgress/100);
    }

    function updateSlider(){
        let isVideo1=(video.style.display === "block")
        let currentVideo = isVideo1 ? video : video2;
        if (currentVideo.currentTime === 0)
            document.getElementById("videoSlider").value = 0;
        else
            document.getElementById("videoSlider").value = (currentVideo.currentTime / currentVideo.duration)*100;
    }

    function videoResize(){
        let videoContainer = document.getElementById("vCon");
        let videoControls = document.getElementById("videoControls");
        let isVideo1=(video.style.display === "block")
        let currentVideo = isVideo1 ? video : video2;
        if (videoContainer === document.fullscreenElement){
            videoControls.style.left = (window.outerWidth/2 - videoControls.offsetWidth/2) + "px";
        }
        else {
            videoControls.style.left = (currentVideo.style.left + currentVideo.offsetWidth/2 - videoControls.offsetWidth/2) + "px";
        }
    }
    function changeVolume(){
        video.volume = document.getElementById("volumeSlider").value;
        video2.volume = document.getElementById("volumeSlider").value;
    }

    //Returns a jsonObject based on the index attribute
    function filterByIndex(jsonObject, index){
        return jsonObject.filter(function (jsonObject){ return (jsonObject["index"] === index);})[0];
    }

    //Returns a jsonObject based on the tag attribute
    function filterByTag(jsonObject, tag){
        return jsonObject.filter(function (jsonObject){return (jsonObject["tag"] === tag);})[0];
    }



</script>

</body>
</html>